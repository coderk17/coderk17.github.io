[{"title":"My New Post","url":"/2022/08/28/My-New-Post/","content":"import os\nimport re\nimport pty\nimport json\nimport time\nimport fcntl\nimport struct\nimport termios\nimport asyncio\nfrom json import JSONDecodeError\n\nfrom fastapi.websockets import WebSocket, WebSocketDisconnect\n\n# 文件写入状态\nWRITE_FILE_ING = 0\nWRITE_FILE_SUC = 1\nWRITE_FILE_ERR = 2\n\n# 文件上传状态\nUPLOAD_ING = 0\nUPLOAD_SUC = 1\nUPLOAD_ERR = 2\n\n# pty_stream服务实例状态\nSERVICE_RUNING = 1\nSERVICE_CLOSED = 2\n\n\nclass PtyStream:\n    \"\"\"终端IO流管理\"\"\"\n    def __init__(self, websocket: WebSocket, event_mode: bool = True):\n        self.websocket = websocket\n        self.fd = self.get_pty_fd()\n        self.block_size = 32 * 1024\n        self.fd_event_mode = None\n        # 每个分片header信息长度记录大小\n        self.record_header_size = 16\n        self.upload_dir = os.path.join(os.path.expanduser('~'), \"upload-data\")\n        \"\"\" 记录每个文件上传过程中保存的中间信息，传输完成后即销毁\n        self.upload_info = &#123;\n            $filename: &#123;\n                checked_filename: $checked_filename,                // 经过重名处理后的文件名\n                filepath: $filepath,                                // 文件路径\n                next_merge_start_index: $next_merge_start_index     // 下一次merge的起始子文件索引\n                file_write_info: &#123;                                  // 子文件写入状态\n                    $block_index: $write_status \n                &#125;,\n                status: $status                             // 运行状态，若成功则无此状态，若由此状态表示为异常终端此次传输\n            &#125; \n        &#125; \"\"\"\n        self.upload_info = &#123;&#125;\n        # 文件名及文件分片后子文件的文件名格式模板\n        self.filepath_format = f\"&#123;self.upload_dir&#125;/%s\"\n        self.subfilepath_format = f\"&#123;self.upload_dir&#125;/.%s_%s\"\n        # 匹配括号\n        self.re_match_bracket = re.compile(r\"（\\d+）\")\n        self.status = SERVICE_RUNING\n        # 注册事件监听\n        self.events = websocket.app.events\n        self.events.register_read_event(self.fd, self, event_mode)\n\n    def __enter__(self):\n        return self\n\n    def __exit__(self, exc_type, exc_value, exc_tb):\n        if self.status == SERVICE_RUNING:\n            self._close()\n\n    def __del__(self):\n        if self.status == SERVICE_RUNING:\n            self._close()\n\n    def get_pty_fd(self) -> int:\n        \"\"\" 创建伪终端，执行预处理命令并返回伪终端对应的文件描述符\n\n        :return: 伪终端的文件描述符\n        \"\"\"\n        pid, fd = pty.fork()\n        if pid == pty.CHILD:\n            # 启动脚本，可以执行预处理命令，或更改环境\n            os.execlp(\"/bin/bash\", *[\"/bin/bash\"])\n        return fd\n\n    def _read(self):\n        \"\"\"pty输出\"\"\"\n        try:\n            text = os.read(self.fd, self.block_size)\n        except OSError as os_err:\n            raise Exception(f\"PtyStream:_read:&#123;os_err&#125;\")\n        except Exception as err:\n            raise Exception(f\"PtyStream:_read:&#123;err&#125;\")\n        else:\n            return text\n\n    def _write(self, data: str):\n        \"\"\"pty输入\"\"\"\n        os.write(self.fd, bytes(data, encoding=\"utf-8\"))\n\n    def _close(self):\n        \"\"\"pty关闭\"\"\"\n        self.status = SERVICE_CLOSED\n        os.close(self.fd)\n        self.events.unregister(self.fd)\n        raise WebSocketDisconnect(\"终端关闭，断开连接\")\n\n    async def on_read(self):\n        \"\"\"读取pty stdout并通过websocket发送给客户端\"\"\"\n        text = self._read()\n        await self.websocket.send_text(text)\n        if text[-6:] == b'exit\\r\\n':\n            close_msg = \"您已经断开连接，输入已关闭，请尝试另一次连接。\"\n            await self.websocket.send_text(bytes(close_msg, encoding=\"utf-8\"))\n            self._close()\n\n    def clear_stdout_buffer(self):\n        \"\"\"清空pty stdout缓冲区\"\"\"\n        self._read()\n\n    def exec_command(self, command: str):\n        \"\"\" pty执行命令行\n\n        :param command: 要执行的命令行字符串\n        :return:\n        \"\"\"\n        try:\n            os.write(self.fd, bytes(f\"&#123;command&#125;\\r\", encoding=\"utf-8\"))\n        except Exception as err:\n            raise Exception(f\"exec_command:&#123;command&#125;:&#123;err&#125;\")\n\n    def resize_window(self, rows: int, cols: int):\n        \"\"\" pty终端大小设置\n\n        :param rows: 行数\n        :param cols: 列数\n        :return:\n        \"\"\"\n        width, height = cols, rows\n        TIOCSWINSZ = getattr(termios, 'TIOCSWINSZ', -2146929561)\n        s = struct.pack('HHHH', width, height, 0, 0)\n        fcntl.ioctl(self.fd, TIOCSWINSZ, s)\n\n    async def process_pty_recv(self, message: str):\n        \"\"\" 传入pty数据的处理逻辑\n\n        :param message: 传入pty的数据\n        :return:\n        \"\"\"\n        try:\n            if self.status != SERVICE_RUNING:\n                raise WebSocketDisconnect(\"终端关闭，断开连接\")\n            try:\n                msg = json.loads(message)\n            except JSONDecodeError:\n                raise Exception(\"process_pty_recv:%s\" % message)\n\n            resize = msg.get('resize')\n            if resize and len(resize) == 2:\n                try:\n                    self.resize_window(*resize)\n                except Exception as err:\n                    raise Exception(\"process_pty_recv:resize:%s\" % err)\n\n            data = msg.get('data')\n            if data and isinstance(data, str):\n                self._write(data)\n        except WebSocketDisconnect as disconnect_err:\n            raise disconnect_err\n        except Exception as err:\n            raise Exception(\"process_pty_recv:%s\" % err)\n\n    def _check_filename(self, filename: str, max_dup_file_nums: int = 5) -> str:\n        \"\"\" 检测文件名是否已存在，若已存在，则在该文件名中加上重名标识符\n\n        若上传文件夹中已包含a.txt，再次上传a.txt，会生成一个a（1）.txt文件，\n        若再次上传a.txt会生成a（2）.txt，可更改max_dup_file_nums控制标识符\n        最大值，默认为5\n\n        :param filename: 检测的文件名\n        :param max_dup_file_nums: 添加的标识符最大值\n        :return: 检测处理完成后的文件名\n        \"\"\"\n        for i in range(max_dup_file_nums + 1):\n            exist_status = os.path.exists(self.filepath_format % filename)\n            if exist_status:\n                if i == max_dup_file_nums:\n                    raise Exception(\"Duplicated file is too much, please change file name.\")\n                if len(filename) > 1024:\n                    raise Exception(\"Filename's length is too long.\")\n\n                if self.re_match_bracket.search(filename):\n                    filename = self.re_match_bracket.sub(\"\", filename)\n                if \".\" in filename:\n                    filename_split = filename.split(\".\")\n                    filename = \".\".join(filename_split[:-1]) + f\"（&#123;i + 1&#125;）\" + \".\" + filename_split[-1]\n                else:\n                    filename = filename + f\"（&#123;i + 1&#125;）\"\n            else:\n                break\n        return filename\n\n    def _write_file(self, filepath: str, data: bytes) -> int:\n        \"\"\" 指定文件路径，写入数据，并返回写入成功状态\n\n        :param filepath: 文件路径\n        :param data: 数据\n        :return: 成功状态，WRITE_FILE_ERR表示写入失败，WRITE_FILE_SUC表示写入成功\n        \"\"\"\n        try:\n            with open(filepath, \"wb+\") as f:\n                f.write(data)\n        except Exception as err:\n            status = WRITE_FILE_ERR\n        else:\n            status = WRITE_FILE_SUC\n        return status\n\n    async def _merge_sub_file(self, ori_filename: str, start_index: int, end_index: int, timeout: int = 5):\n        \"\"\" 合并上传文件的切片子文件\n\n        :param ori_filename: 客户端上传的文件原名\n        :param start_index: 处理的起始子文件索引\n        :param end_index: 处理的终止子文件索引\n        :param timeout: 处理的超时时间\n        :return:\n        \"\"\"\n        try:\n            upload_info = self.upload_info[ori_filename]\n            file_write_info = upload_info[\"file_write_info\"]\n            filepath = upload_info[\"filepath\"]\n            checked_filename = upload_info[\"checked_filename\"]\n            check_indexes = list(range(start_index, end_index + 1))\n            starttime = time.time()\n            while (time.time() - starttime) &lt; timeout:\n                new_check_indexes = []\n                for i in check_indexes:\n                    if i not in file_write_info:\n                        raise Exception(\"上传文件传输包缺失：filename:%s,start_index:%s,end_index:%s\" % (ori_filename, start_index, end_index))\n                    if file_write_info[i] == WRITE_FILE_ERR:\n                        raise Exception(\"上传文件传输包写入失败：filename:%s,start_index:%s,end_index:%s\" % (ori_filename, start_index, end_index))\n                    if file_write_info[i] == WRITE_FILE_ING:\n                        new_check_indexes.append(i)\n                check_indexes = new_check_indexes\n                if len(check_indexes) == 0:\n                    break\n                await asyncio.sleep(0.1)\n            if len(check_indexes) != 0:\n                raise Exception(\"上传文件处理超时，filename: %s\" % ori_filename)\n            for i in range(start_index, end_index + 1):\n                subfilepath = self.subfilepath_format % (checked_filename, i)\n                command_merge = f\"cat &#123;subfilepath&#125; >> &#123;filepath&#125;\"\n                self.exec_command(command_merge)\n                command_del_sub = f\"rm &#123;subfilepath&#125;\"\n                self.exec_command(command_del_sub)\n        except Exception as err:\n            raise Exception(\"_merge_sub_file:%s\" % err)\n\n    async def process_recv_file_bytes(self, message: bytes):\n        \"\"\" 文件上传中获取数据流的处理程序\n\n        :param message: 文件上传中获取的数据流\n        :return:\n        \"\"\"\n        try:\n            if self.status != SERVICE_RUNING:\n                raise WebSocketDisconnect(\"终端关闭，断开连接\")\n            # 当子文件个数达到merge_block_size时执行merge到父文件操作\n            MERGE_BLOCK_SIZE= 10\n            # FIXME 文件传输如果有阻塞会对终端操作产生影响，改为非阻塞文件传输，目前分片大小为1M上传无阻塞\n            # 目前只有上传文件功能，没有上传文件夹功能，后期如果需要可以加上\n            header_info_end_index = int(''.join([str(x) for x in message[:self.record_header_size]]))\n            header_info = json.loads(message[self.record_header_size: header_info_end_index])\n            ori_filename = header_info[\"create_file\"]\n            block_index = header_info[\"block_index\"]\n            end_signal = header_info.get(\"end_signal\", False)\n            message = message[header_info_end_index:]\n            if block_index == 0:\n                # 第一个数据块检查文件名重名并创建文件，同时初始化传输过程数据（upload_info）\n                checked_filename = self._check_filename(ori_filename, max_dup_file_nums=5)\n                filepath = self.filepath_format % checked_filename\n                self.exec_command(command=f\"touch &#123;filepath&#125;\")\n\n                # TODO 同时上传两个同名文件，需要前端在header里加一个文件唯一标识符字段，\n                # 可以用文件内容哈希值，可以实现同时上传，不过目前来看没有必要加上\n                if ori_filename in self.upload_info:\n                    raise Exception(\"正在上传一个同名文件，不能同时上传两个同名文件\")\n                upload_info = self.upload_info.setdefault(ori_filename, &#123;&#125;)\n                upload_info[\"checked_filename\"] = checked_filename\n                upload_info[\"filepath\"] = filepath\n                upload_info[\"file_write_info\"] = &#123;&#125;\n                upload_info[\"next_merge_start_index\"] = 0\n\n            upload_info = self.upload_info[ori_filename]\n            checked_filename = upload_info[\"checked_filename\"]\n            file_write_info = upload_info[\"file_write_info\"]\n            # 接收信息，写入子文件，并记录写入状态\n            file_write_info.setdefault(block_index, WRITE_FILE_ING)\n            subfilepath = self.subfilepath_format % (checked_filename, block_index)\n            write_status = self._write_file(subfilepath, message)\n            file_write_info[block_index] = write_status\n\n            # merge子文件内容到结果文件中\n            # 可优化为merge_block_size个线程执行，不影响总顺序，\n            # 因为每次合并时会给这merge_block_size个文件检查存在性并排序\n            next_merge_start_index = upload_info[\"next_merge_start_index\"]\n            if (((block_index + 1) % MERGE_BLOCK_SIZE == 0)\n                or end_signal):\n                await self._merge_sub_file(\n                    ori_filename,\n                    start_index=next_merge_start_index,\n                    end_index=block_index\n                )\n                upload_info[\"next_merge_start_index\"] = block_index + 1\n\n            if end_signal:\n                del(self.upload_info[ori_filename])\n        except WebSocketDisconnect as disconnect_err:\n            raise disconnect_err\n        except Exception as err:\n            # TODO 报错时保存其他上下文，如已传输文件内容哈希，各子文件名及哈希，多请求几个包校验前端传输分片内容是否可信任\n            if ori_filename in self.upload_info:\n                self.upload_info[ori_filename][\"status\"] = UPLOAD_ERR\n            resp = &#123;\n                \"create_file\": header_info[\"create_file\"],\n                \"block_index\": block_index,\n                \"block_end_signal\": end_signal,\n                \"msg\": str(err),\n                \"status_code\": 500\n            &#125;\n            raise Exception(\"process_recv_file_bytes:%s\" % err)\n        else:\n            resp = &#123;\n                \"create_file\": header_info[\"create_file\"],\n                \"block_index\": block_index,\n                \"block_end_signal\": end_signal,\n                \"msg\": \"OK\",\n                \"status_code\": 200\n            &#125;\n        finally:\n            await self.websocket.send_text(json.dumps(resp))\n\n函数：f(x)=anxn+an−1xn−1+an−2xn−2+⋯{f(x)=a_nx^n+a_{n-1}x^{n-1}+a_{n-2}x^{n-2}}+\\cdotsf(x)=an​xn+an−1​xn−1+an−2​xn−2+⋯\nf(x)=anxn+an−1xn−1+an−2xn−2+⋯(1.1){f(x)=a_nx^n+a_{n-1}x^{n-1}+a_{n-2}x^{n-2}}+\\cdots \\tag{1.1}\nf(x)=an​xn+an−1​xn−1+an−2​xn−2+⋯(1.1)\n","categories":["编程语言"],"tags":["Python"]},{"title":"Hello World","url":"/2022/08/28/hello-world/","content":"Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub.\n Quick Start\n Create a new post\n$ hexo new \"My New Post\"\nMore info: Writing\n Run server\n$ hexo server\nMore info: Server\n Generate static files\n$ hexo generate\nMore info: Generating\n Deploy to remote sites\n$ hexo deploy\nMore info: Deployment\n","categories":[],"tags":[]}]